#Mysql优化之Schema与数据类型

## 选择优化的数据类型
Mysql支持的数据类型非常多，选择正确的数据类型对于获得高性能很重要，下面是一些参考原则：
- 更小的通常更好
    一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常一般更快，因为占用更少的磁盘，内存和CPU缓存，并且处理时需要CPU周期也更少
- 简单就好
    简单数据类型的操作通常需要更少的CPU周期。例如：整型比字符串操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。例子：应该使用mysql内建的类型而不是字符串来存储日期和时间，应该使用整型类存储IP地址。
- 尽量避免NULL
    很多表都包含可为NULL的列，即使应用程序并不需要保存null也是如此。这是因为可为null是列的默认属性。通常情况下最好指定列为`NOT NULL`，除非真的需要存储`NULL`值。
    如果查询中包含可为NULL的列，对mysql来说更难优化，因为可为NULL的列使的索引、索引统计和值比较更复杂。可为NULL的列会使用更多的存储空间。在mysql中也需要特殊的处理。
    当可为NULL的列被索引时，每个索引记录需要一个额外的字节，MyISAM里甚至还可能导致固定大小的索引变为可变大小的索引。如果需要在列上建索引，就应该避免设计为可为NULL的列。
    在我们选择时间类型的时候，timestamp类型和datatime都可以存储相同类型的数据：时间和日期，精确到秒。按时timestamp的所占的存储空间是datetime的一半，并且timestamp会根据时区的变化而变化，具有自动更新的能力。
    另外，timestamp允许的范围要小很多。
- mysql 为了兼容性支持别名，但是mysql查询的时候还是基于基本类型的。我们可以使用show命令查询创建表的详细信息
    ```MYSQL
        SHOW CREATE TABLE mytable;
    ```
## Mysql中的数据类型

- 整数类型
    - 整型：存储整数，可以使用如下类型：TINYINT，SMALLINT，MEDIUMINT，Bigint。
  整数类型有可选的UNSIGNED，表示不能为负值。这个可以使正数的上线提高一倍。有符号和无符号使用相同的存储空间。并具有相同的性能。整数计算一般使用64位的bigint整数。
    - 实数类型：实数是具有小数部分的数值。然而，它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。mysql支持精度类型，也支持不精确类型。
  float和double类型支持使用标准的浮点运算进行近似计算。DECIMAL类型用于存储精确的小数。支持精确计算。浮点和DECIMAL类型都可以指定精度，对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。
  因为DECIMAL需要更多的存储空间，因此尽量少用DECIMAL，除非要进行精确计算。当数据量比较大是，可以使用bigint进行代替，乘以相应的倍数进行存储即可。
- 字符串类型：Mysql支持多种字符串类型，从4.1版本开始，每个字符串列可以自定义字符集和排序规则，或者说校对规则。
  - varchar和char类型：varchar和char是两种最主要的字符串类型。存储跟锁使用的存储引擎有关。
    - varchar:varchar类型用于存储可变长度字符串，比定长类型更节省空间，因为它仅使用必要的空间，如果使用ROW_FORMAT=FIXED创建的话，每一行都会为定长存储，很浪费空间。
    varchar需要使用1或2个额外字节记录字符串的长度，如果列的最大 长度小于或者等于255字节，则只使用1个字节表示。否则使用2个字节。varchar节省了存储空间，因此对性能也有帮助。
    但是，由于是行是变长的，在update时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且页内没有更多的空间可以存储，在这种情况下，MyISAM会将行拆成不同的片段UNC
    InnoDB则需要分裂页来使行可以放进页内。
    - char：char类型是定长的，mysql会根据定义的字符串长度分配足够的空间。当存储char时，mysql会删除所有的末尾空格。char值会根据需要采用空格进行填充以方便比较。char适合存储很短的字符串，或者所有的
    值都接近同一个长度。因为定长的char类型不容易产生碎片。对于非常短的列，char比varchar存储空间上也更有效率。
    - BINARY和VARBINARY，它们存储的是二进制字符串。二进制字符串跟常规字符串非常相近，但是二进制字符串存储的是字节码而不是字符。填充也一样。mysql填充BINARY采用的\0（零字节）而不是空格，在检索时也不会去掉填充值。
    我们在使用varchar的时候，varchar(5)和varchar(200)存储存储值5个字符的开销是一样的，使用短列的优势：
    `1. 更长的列会消耗更多的内存，因为mysql通常会分配固定大小的内存块来保存内部值，尤其是使用内存临时表进行排序和操作时会特别糟糕。在利用磁盘临时表进行排序时也很糟糕。`
-BLOB和TEXT类型
    - Blob和Text都是为了存储很大数据而设计的字符串数据类型，一个是基于二进制存储，一个是字符串存储
    - 与其他类型不同，mysql把每一个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来存储，此时每个值在行内需要1~4个字节存储一个指针，然后再外部存储区域存储实际的值
    - blob没有排序规则和字符集，TEXT有排序规则和字符集
    - mysql对TEXT列进行排序的时候，它只对每个列的最前max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减小max_sort_length的配置，或者使用ORDER BY SUBSTRING(column,length)
    - mysql不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序
- 枚举（ENUM）类型
    可以使用枚举代替常用的字符串类型，枚举列可以把一些不重复的字符串存储成一个预定义的集合。mysql在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或两个字节中。
    mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”
    枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。我们可以使用`FIELD()`函数显式地指定排序顺序，但是会导致mysql无法利用索引消除排序。
- 日期和时间类型
    Mysql可以使用许多类型来保存时间，如Year和DATE。mysql能存储的最小时间粒度为秒，MariaDB支持微秒级别的，但是mysql也可以使用微秒级别的进行临时运算。
    - datetime：这个类型能保存大范围的值，从1001到9999年，精确到秒。与时区无关。使用8个字节的存储空间
    - timestamp：保存了从1970年1月1日午夜以来的秒数，它和unix时间戳相同。只能显示1970年到2038年。mysql提供了FROM_UNIXTIME()函数把unix时间戳转换为时间并提供UNIX_TIMESTAMP()函数把日期转换为unix时间戳
  timestamp显示的值依赖于时区。mysql server/操作系统以及客户端链接都有时区设置。默认情况下，如果插入时没有指定第一个timestamp列的值，mysql会设置这个列为当前时间。在插入一行数据时，mysql默认也会更新第一个timestamp列的值，可以配置任何timestamp列的插入和更新行为。
    - timestamp列默认为NOT NULL。
- 位数据类型
mysql有少数集中存储类型使用紧凑的位存储数据，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型
  - BIT：可以使用bit列在一列中存储一个或者多个true/false值。bit（1）另一个包含单个位的字段，bit（2）存储2个位，最长为64位bit（64）。mysql把bit当做字符串类型，
  而不是数字类型。当检索bit(1)的值时，结果是一个包含二进制0或者1值的字符串，然而在数字上下文场景中检索时，结果将是位字符串转换成的数字。
  - SET：如果需要保存很多true/false值，可以考虑合并这些列到一个set数据类型，它在mysql内部是以一系列打包的位的集合来表示的。这样提高了存储空间的利用率，但是修改列的代价很昂贵，需要执行`alter table`。一般也不能通过索引查找。
- JSON类型(MYSQL 8.0+)
  MySQL支持RFC 7159定义的原生JSON数据类型，可以有效地访问JSON (JavaScript对象符号)文档中的数据。与将JSON格式的字符串存储在字符串列中相比，JSON数据类型提供了这些优点：
  - 动验证JSON列中存储的JSON文档。无效的文档会产生错误。
  - 优化的存储格式。存储在JSON列中的JSON文档被转换为允许对文档元素进行快速读取访问的内部格式。当服务器以后必须读取以这种二进制格式存储的JSON值时，不需要从文本表示中解析该值。二进制格式的结构使服务器能够直接通过键或数组索引查找子对象或嵌套值，而无需读取文档中它们之前或之后的所有值。
  - MySQL 8.0还支持RFC 7396中定义的JSON Merge Patch格式，使用JSON_Merge_Patch()函数
  
## Mysql标识列选择数据类型的一些小技巧
  
- 整数类型是标识列最好的选择，因为快并且可以使用auto_increment
- enum和set通常禁止使用作为标识列的数据类型。ENUM和SET列适合存储固定信息，例如性别，产品类型等
- 字符串类型：如果可能，也应该避免使用字符串类型作为标识列的类型，因为他们比较消耗空间，并且通常比数字类型慢。对于完全随机的字符串要多加注意，如使用一些函数MD5()，SHA1()或者UUID()产生的字符串，因为这些函数生成的新值会任意分布在很大的空间内。这会导致insert和select语句变得很慢。
  - 因为插入值会随机地写到索引的不同位置，所以使得insert语句更慢。这会导致页分裂、磁盘随机访问以及对于聚簇存储引擎产生聚簇索引碎片。
  - select会更慢是因为逻辑上相邻的行会分布在磁盘和内存的不同地方
  - 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效，如果整个数据集都一样的热，那么缓存任何一部分特定数据到内存都没有好处。如果工作集比内存大，缓存将会有很多刷新和不命中。
  - 如果存储uuid的值，最好移除掉分割符‘-’，或者使用UNHEX()函数转换为16字节的数字，一并存储在一个BINARY(16)列中，检索的时候通过HEX()函数来格式化为十六进制格式
  
## 存储IP地址

  我们通常存储IP地址，经常使用varchar(15)列来存储ip地址。然而，他们实际上是32位无符号整数，不是字符串。因此推荐使用无符号的整数存储IP地址。
mysql提供了INET_ATON()和INET_NTOA()函数这这两种标识方法之间转换。

## Mysql schema设计中的坑

- 太多的列
    mysql的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓存内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价会很高。
- 太多的关联
    所谓的EAV(实体-属性-值)设计模式是一个常见的糟糕设计模式，mysql限制了每一个关联操作最多只能有61张表，但是EAV需要许多的自关联。单个查询最好在12个表以内做关联。
- 全能的枚举
    注意防止过度使用枚举。
- 变相的枚举
    枚举列允许在列中存储一组定义值中的个值，集合set列则允许在列中存储一组定义值中的一个或多个值
- 避免使用NULL

## 范式化和反范式化

- 范式化：每个事实数据会出现并且只出现一次。
  - 范式化的更新操作通常比较快
  - 不会出现大量的重复数据，这样只需要修改的数据量少
  - 范式化的表通常不大，可以更好地放在内存中，执行操作更快
  - 更少需要执行group by等语句
  - 范式化需要关联，可能使一些索引无效
- 反范式化：信息是冗余的，可能会存储在多个地方
  - 所有的数据都在一张表中，可以更好的避免关联，查询会更快，因为不需要关联，避免了随机I/O操作
  - 单独表可以更好的使用索引
在平时开发中，一般都混合使用。
  
## 加快alter table操作的速度

mysql的alter table操作的性能对大表来说是个大问题。mysql执行大部分修改表结构操作的方法步骤是先创建一个空表，从旧表中查出所有的数据插入新表，然后删除旧表。
大部分alter table操作会导致mysql服务中断。我们可以使用如下两种方式：
- 现在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换
- 使用影子拷贝：是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删除表操作交换两张表

我们在通过alter table的时候，有些情况是可以跳过创建新表的。列的默认值实际上存在表的.frm文件中，可以直接修改这个文件而不需要改动表本身。然而mysql还没有采用这种优化的方法，所有的modify column操作都会导致重新建表。
我们可以通过alter column操作进行，这个会直接修改.frm文件而不会重建新表，这种操作非常快。
- 只修改frm文件(有风险，最好执行的时候，将数据进行备份)

