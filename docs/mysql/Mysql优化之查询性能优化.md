# Mysql优化之查询性能优化
## 为什么查询速度会慢？
    查询可以看做是一个任务，任务中由一些子任务组成，每个子任务都会消耗一定的时间。优化查询就是优化其子任务，一种是减少子任务的次数，一种是提高子任务的性能。
## 查询的生命周期：
    从客户端到服务端
    服务端进行sql解析
    生成执行计划
    执行执行计划
    返回结果给客户端
**执行**是整个生命周期中最重要的阶段，包含了大量的检索数据到存储引擎的调用以及调用之后的处理，如排序，分组等操作
## 优化数据访问
   查询比较慢最基本原因是由于访问的数据量太大，查询可能不避免的需要筛选大量的数据，但是这样操作不是很常见，可以通过如下两个方面：
   1. 确认应用是否在检索大量超过需要的数据，这通常是访问了大量的行或者访问了太多的列。
   2. 确认mysql服务器层是否在分析大量超过需要的数据行
   - 优化点：
       - 查询不需要的记录，我们需要做的就是需要什么数据，返回什么数据
       - 多表关联的时候返回全部列，需要什么列返回什么列，建议不要使用*去关联查询数据
       - 总是取出所有列，取出所有列`Select * `会让优化器无法完成索引覆盖扫描这类优化，还会带来额外的I/O操作、内存和CPU消耗
       - 重复查询相同的数据，可以使用缓存进行处理

## Mysql是否在扫描额外的记录

    衡量mysql查询开销的三个指标：
    - 响应时间
    - 扫描的行数
    - 返回的行数
  可以通过查询慢日志找出扫描行数过多的查询
## 重构查询
    - 切分查询
        有时候我们需要将一个大查询切分为小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。对于删除来说，定期清理数据
        的时候执行删除的时候，有可能需要一次锁定很多数据，占满整个事务日志，耗尽系统资源，阻塞许多小的但重要的查询将一个大的delete语句切分
        成多个小的查询可以尽可能小的影响mysql性能，同时还可以减少mysql复制的延迟。
    - 分解关联查询
        有时候我们需要将对关联查询进行分解，就是将每一个表进行一次单表查询，然后将结果在应用程序中进行关联.优点：
        - 让缓存的效率更高，对与mysql的查询缓存来说，如果关联中的某个表发生了变化，那么就无法走缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了
        - 可以减少锁的竞争
        - 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
        - 查询效率可能会有所提高
        - 可以减少冗余记录的查询
        - 这样做相当于在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。
## 查询执行
    Mysql查询数据执行过程：
    - 客户端发送一条查询给服务器
       a. 客户端和mysql服务器之间的通信是半双工的，在任何一个时刻，要么是由服务器向客户端发送数据，要么是客户端向服务器端发送数据
       b. 一般服务器响应给客户端的数据通常很多，有多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整的接受整个返回结果，
       而不能简单的只取前面几条结果，然后让服务器停止发送数据，这也是在查询的时候添加limit的原因。
    - 服务器先检查缓存，如果命中缓存，则立刻返回存储在缓存中的结果。
    - 未命中缓存进行sql解析/预处理，再由优化器生成对应的执行计划
    - Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询
    - 返回结果给客户端，并将结果写入缓存中
## 查询状态
    对于一个mysql链接，或者说一个线程任何时刻都会有一个状态，表示mysql正在做什么
    - Sleep：线程正在等待客户端发送新的请求
    - query： 线程正在执行查询或者正在将结果发送给客户端
    - locked：表示正在等待表锁
    - Analyzing and statistics:线程正在收集存储引擎的统计信息，并生成查询的执行计划
    - copying to tmp table[on disk]：线程正在执行查询，并且将其结果集都复制到一个临时表中
    - sorting result：线程正在对结果集进行排序
    - sending data:表示多种情况，线程可能在多个状态直接按传送数据，或者在生成结果集，或者在向客户端返回数据
## 查询优化处理
### 语法解析器和预处理
    - 语法解析器：mysql通过关键字将sql语句进行解析，并生成一颗对应的“解析树”。mysql解析器将使用mysql语法规则验证和解析查询。
    - 预处理：会根据一些mysql的规则进行进一步检查解析树是否合法。之后会进行相关权限的验证。
### 查询优化器
    上面的语法树检查没有问题，优化器会将其转化成执行计划。一条查询可以有很多种执行方式，最后都会返回相同的结果，优化器的作用就是找到最好的执行计划。
    mysql基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。最初，成本最小的单位就是随机读取一个4K数据页的成本，
    后来就变得复杂了，引入了一些因子来估算某些操作的代价，可以通过下面的命令查询当前查询的成本：
    ```sql
    show status like 'last_query_cost';
    ```
    查询成本计算由每个表或者索引的页面个数/索引的基数/索引和数据行的长度/索引的分布情况计算的来的。
    但是优化器有时候也会出现选择错误的执行计划：
    - 统计信息不准确
    - 执行计划中的成本估算不等同于实际执行的成本
    - mysql的最优可能和自己想象的最优不一样
    - mysql从不考虑并发执行的查询
    - mysql也并不是任何时候都是基于成本的优化
    - mysql不会考虑不受其控制的操作的成本
    优化策略：
    - 静态优化：可以直接对解析树进行分析，并完成优化
    - 动态优化：与查询的上下文有关，每次查询的时候都会重新评估
### mysql如何进行关联查询
    mysql认为任何一个查询都是一次关联，并不仅仅是一个查询需要到多张表匹配才叫关联。所以在mysql中，每一个查询，每一个片段都可能是关联。
    - union查询：对于union查询，mysql先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成union查询。
    mysql对任何关联都执行嵌套循环关联操作。即mysql先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止，
    然后根据各个表匹配的行，返回查询中需要的各个列，mysql会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，mysql返回到上一层次关联表，看是否能够找到更多的匹配记录，依次类推迭代执行
### 关联查询优化器
    mysql优化器最重要的一部分就是关联查询优化，决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果，mysql会通过评估不同顺序是的成本来选择一个代价最小的关联顺序。
### 排序优化
    无论如何排序都是一个高成本的操作，所有从性能角度考虑，应尽量避免排序或者尽可能避免对大量数据进行排序
    当不能使用索引进行排序的时候，mysql将进行**文件排序**，即数据量小则在内存中进行，如果数据量大的话就需要使用磁盘。




