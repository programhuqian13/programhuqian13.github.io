# Mysql优化之查询性能优化
## 为什么查询速度会慢？
    查询可以看做是一个任务，任务中由一些子任务组成，每个子任务都会消耗一定的时间。优化查询就是优化其子任务，一种是减少子任务的次数，一种是提高子任务的性能。
## 查询的生命周期：
    从客户端到服务端
    服务端进行sql解析
    生成执行计划
    执行执行计划
    返回结果给客户端
**执行**是整个生命周期中最重要的阶段，包含了大量的检索数据到存储引擎的调用以及调用之后的处理，如排序，分组等操作
## 优化数据访问
   查询比较慢最基本原因是由于访问的数据量太大，查询可能不避免的需要筛选大量的数据，但是这样操作不是很常见，可以通过如下两个方面：
   1. 确认应用是否在检索大量超过需要的数据，这通常是访问了大量的行或者访问了太多的列。
   2. 确认mysql服务器层是否在分析大量超过需要的数据行
   - 优化点：
       - 查询不需要的记录，我们需要做的就是需要什么数据，返回什么数据
       - 多表关联的时候返回全部列，需要什么列返回什么列，建议不要使用*去关联查询数据
       - 总是取出所有列，取出所有列`Select * `会让优化器无法完成索引覆盖扫描这类优化，还会带来额外的I/O操作、内存和CPU消耗
       - 重复查询相同的数据，可以使用缓存进行处理

## Mysql是否在扫描额外的记录

    衡量mysql查询开销的三个指标：
    - 响应时间
    - 扫描的行数
    - 返回的行数
  可以通过查询慢日志找出扫描行数过多的查询
## 重构查询
    - 切分查询
        有时候我们需要将一个大查询切分为小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。对于删除来说，定期清理数据
        的时候执行删除的时候，有可能需要一次锁定很多数据，占满整个事务日志，耗尽系统资源，阻塞许多小的但重要的查询将一个大的delete语句切分
        成多个小的查询可以尽可能小的影响mysql性能，同时还可以减少mysql复制的延迟。
    - 分解关联查询
        有时候我们需要将对关联查询进行分解，就是将每一个表进行一次单表查询，然后将结果在应用程序中进行关联.优点：
        - 让缓存的效率更高，对与mysql的查询缓存来说，如果关联中的某个表发生了变化，那么就无法走缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了
        - 可以减少锁的竞争
        - 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
        - 查询效率可能会有所提高
        - 可以减少冗余记录的查询
        - 这样做相当于在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。
## 查询执行
    Mysql查询数据执行过程：
    - 客户端发送一条查询给服务器
       a. 客户端和mysql服务器之间的通信是半双工的，在任何一个时刻，要么是由服务器向客户端发送数据，要么是客户端向服务器端发送数据
       b. 一般服务器响应给客户端的数据通常很多，有多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整的接受整个返回结果，
       而不能简单的只取前面几条结果，然后让服务器停止发送数据，这也是在查询的时候添加limit的原因。
    - 服务器先检查缓存，如果命中缓存，则立刻返回存储在缓存中的结果。
    - 未命中缓存进行sql解析/预处理，再由优化器生成对应的执行计划
    - Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询
    - 返回结果给客户端，并将结果写入缓存中
## 查询状态
    对于一个mysql链接，或者说一个线程任何时刻都会有一个状态，表示mysql正在做什么
    - Sleep：线程正在等待客户端发送新的请求
    - query： 线程正在执行查询或者正在将结果发送给客户端
    - locked：表示正在等待表锁
    - Analyzing and statistics:线程正在收集存储引擎的统计信息，并生成查询的执行计划
    - copying to tmp table[on disk]：线程正在执行查询，并且将其结果集都复制到一个临时表中
    - sorting result：线程正在对结果集进行排序
    - sending data:表示多种情况，线程可能在多个状态直接按传送数据，或者在生成结果集，或者在向客户端返回数据
## 查询优化处理
### 语法解析器和预处理
    - 语法解析器：mysql通过关键字将sql语句进行解析，并生成一颗对应的“解析树”。mysql解析器将使用mysql语法规则验证和解析查询。
    - 预处理：会根据一些mysql的规则进行进一步检查解析树是否合法。之后会进行相关权限的验证。
### 查询优化器
    上面的语法树检查没有问题，优化器会将其转化成执行计划。一条查询可以有很多种执行方式，最后都会返回相同的结果，优化器的作用就是找到最好的执行计划。
    mysql基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。最初，成本最小的单位就是随机读取一个4K数据页的成本，
    后来就变得复杂了，引入了一些因子来估算某些操作的代价，可以通过下面的命令查询当前查询的成本：
    ```sql
    show status like 'last_query_cost';
    ```
    查询成本计算由每个表或者索引的页面个数/索引的基数/索引和数据行的长度/索引的分布情况计算的来的。
    但是优化器有时候也会出现选择错误的执行计划：
    - 统计信息不准确
    - 执行计划中的成本估算不等同于实际执行的成本
    - mysql的最优可能和自己想象的最优不一样
    - mysql从不考虑并发执行的查询
    - mysql也并不是任何时候都是基于成本的优化
    - mysql不会考虑不受其控制的操作的成本
    优化策略：
    - 静态优化：可以直接对解析树进行分析，并完成优化
    - 动态优化：与查询的上下文有关，每次查询的时候都会重新评估
### mysql如何进行关联查询
    mysql认为任何一个查询都是一次关联，并不仅仅是一个查询需要到多张表匹配才叫关联。所以在mysql中，每一个查询，每一个片段都可能是关联。
    - union查询：对于union查询，mysql先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成union查询。
    mysql对任何关联都执行嵌套循环关联操作。即mysql先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止，
    然后根据各个表匹配的行，返回查询中需要的各个列，mysql会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，mysql返回到上一层次关联表，看是否能够找到更多的匹配记录，依次类推迭代执行
### 关联查询优化器
    mysql优化器最重要的一部分就是关联查询优化，决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果，mysql会通过评估不同顺序是的成本来选择一个代价最小的关联顺序。
### 排序优化
    无论如何排序都是一个高成本的操作，所有从性能角度考虑，应尽量避免排序或者尽可能避免对大量数据进行排序
    当不能使用索引进行排序的时候，mysql将进行**文件排序**，即数据量小则在内存中进行，如果数据量大的话就需要使用磁盘。
    如果排序的数据量小于排序缓冲区，mysql使用内存进行快速排序操作.如果内存不够排序，那么mysql会先将数据分块，对每一个独立的块使用快速排序进行排序，并将各个块的结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果
    - mysql有如下两种排序算法：
        - 两次传输排序（旧版本）
            读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。
        - 单次传输排序（新版本）
            先读取查询所需要的所有的列，再根据给定列进行排序，最后直接返回排序结果
    - 在进行文件排序的时候需要使用的临时存储空间可能会比想象的要大得多，原因在于mysql在排序时，对每一个排序记录都会分配一个足够长得定长空间来存放。
    - 在关联查询得时候，mysql会有两种情况使用文件排序：
      - 如果order by子句中的所有列都来自关联的第一个表，那么mysql在关联处理的第一个表的时候就进行文件排序
      - 如果排序的时候，order by子句中的所有列来自多张表，就需要将关联的结果放到一个临时表中，然后在所有关联结束后，再进行文件排序，虽然添加了limit的情况下，临时表的数据量也会比较大，
      在mysql5.6+的版本中做了优化处理，如果添加了limit将不对所有的的结果进行排序，而是根据实际情况，选择性的抛弃不满足条件的结果，然后再进行排序
## mysql查询优化器的局限性
    - 关联子查询
        mysql对于子查询的实现是非常糟糕的，特别是在in（）的子查询语句。因为mysql对于in（）列表中的选项有专门的优化策略，但是mysql会将相关的外层表压到子查询中。如果外层表是一个小表还好，但是如果是一个非常大的表，那么查询性能会很差，可以通过group_CONCAT()在in()中构造一个由
        逗号分割的列表，也可以通过exists（）函数进行处理。
    - union的限制
        有时候，mysql无法将限制条件从外出下推到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上。如limit一样如下：
        ```MYSQL
        (SELECT * FROM TEST.TABLE1 ORDER BY LAST_NAME) UNION ALL (SELECT * FROM TEST.TABLE2 ORDER BY LAST_NAME) LIMIT 20;
        ```
        上面这条语句会将table1和table2张的记录放到一个临时表中，之后再取20条数据，如果我们想临时表中的数据不这么多，我们可以使用如下语句：
        ```MYSQL
        (SELECT * FROM TEST.TABLE1 ORDER BY LAST_NAME LIMIT 20) UNION ALL (SELECT * FROM TEST.TABLE2 ORDER BY LAST_NAME LIMIT 20) LIMIT 20;
        ```
        这样临时表中只会存在40条数据，再取20条数据出来。除了性能考虑外，我们要保证顺序一定，我们需要全局加上order by和limit
    - 索引合并优化
        在mysql 5.0 +版本中，当where子句中包含多个复杂条件的时候，mysql能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行
    - 等值传递
        有些时候，等值传递也会对查询性能有很大的影响，在使用in()的时候，如果in列表很大的情况下，并且mysql优化器发现有where/on/using的子句，就会将in()列表都复制应用到关联的各个表中。这样会导致优化和执行都边慢。
    - 并行执行
        mysql无法利用多核特性来并行执行查询
    - 哈希关联
    - 松散索引扫描
        mysql不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。一般情况，mysql的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中的很少数的几个，mysql仍需要扫描这段索引中的每一个条目
    - 最大值和最小值优化
    - 在同一个表上查询和更新
        mysql不允许在同一张表同时进行查询和更新操作。
## 优化特定类型的查询
    - count(): 可以统计某一个列值的数量也可以统计结果集行数。在统计列值时，要求列值不能为空（不统计NULL）。如果希望知道的时结果集的行数，最好使用count(*).
    - 优化关联查询
        - 确保on或者using子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序
        - 确保任何的group by和order by 中的表达式只涉及一个表中的列，这样mysql才有可能会用索引来优化这个过程
        - 需要注意笛卡尔积
    - 优化group by和distinct：在很多场景下，mysql都使用同样的办法优化这两种查询。mysql优化器会在内部处理的时候相互转换这两类查询。可以使用索引来优化，也是最有效的优化办法
        - 当无法使用索引的情况下，group by使用两种策略来完成：
            - 使用临时表
            - 文件排序来做分组
        以上两种可以通过SQL_BIG_RESULT和SQL_SMALL_RESULT来让优化器按照指定方式运行
    - 优化group by with rollup
        分组查询的一个变种就是要求mysql对返回的分组结果再进行一次超级聚合。可以使用group by with rollup子句来实现。最好的办法是是将超级聚合移动到应用程序中去处理
    - 优化limit分页
        在应用系统中进行分页操作的时候，我们一般会使用limit加上偏移量的方法来实现，同时会加上合适的order by子句，如果有对应的索引，通常效率还可以。如果没有索引，mysql需要做大量的文件排序操作。
    - 优化sql_CALC_FOUND_ROWS
        分页的时候，另一个常用的技巧是在limit语句中加上sql_CALC_FOUND_ROWS提示，这样就可以获得去掉limit以后满足条件的行数，因此可以作为分页的总数。有可能这个代价非常高。可以使用缓存优化
    - 优化union查询
        mysql总是通过创建并填充临时表的方式来执行union查询。因此很多优化策略在union查询中都没法很好的使用。经常需要将where，limit，order by等子句下推到union的各个子句中，以便优化器可以充分利用这些条件进行优化。
        除非确实需要服务器消除重复的行，否则就一定要使用union all这一点很重要，如果没有all关键字，mysql会给临时表加上DISTINCT选项。
    - 使用用户自定义变量
        - 不能使用用户自定义变量的场景：
            - 使用用户自定义变量的查询，无法使用查询缓存
            - 不能在使用常量或者标识符的地方使用自定义变量，例如表名，列名和limit子句中
            - 用户自定义变量的生命是在一个连接中有效，不能用作连接间的通信
            - 如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互
            - 在5.0之前的版本，是大小写敏感的，所以需要注意代码在不同mysql版本见的兼容性问题
            - 不能显式的声明自定义变量的类型，mysql的用户自定义变量是一个动态类型
            - mysql优化器在某些场景下可能会将这些变量优化掉，所有这可能导致代码不按预期的方式运行
            - 赋值的顺序和赋值的时间点并不总是固定的，这依赖于优化器的决定
            - 复制符号:=的优先级非常低，所有需要注意，赋值表达式应该使用明确的括号
            - 使用未定义变量不会产生任何语法错误





